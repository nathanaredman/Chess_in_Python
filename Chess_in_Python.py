# -*- coding: utf-8 -*-
"""chessgame_V2

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19GdvDPQ9bNCNdDXSy0uQqQsdmW_qew7T
"""

import numpy as np
import pandas as pd

#premovecheckscan
#postmovecheckscan
#offtheboarderror
# clearpath move check
#while loop for invalid move selections

def clearpathcheck(intermediate_positions,gameboard):
  all_positions = []
  for pieces_ in gameboard.pieces['black_pieces'].values():
    all_positions.append(pieces_.position)
  for pieces_ in gameboard.pieces['white_pieces'].values():
    all_positions.append(pieces_.position)
  obstructed_path = False
  for checkspots in intermediate_positions:
    if checkspots in all_positions:
      obstructed_path = True
  return obstructed_path

class ChessPiece:
  column_range = ['A','B','C','D','E','F','G','H']
  row_range =[1,2,3,4,5,6,7,8]
  def __init__(self, color, position, name, status = 'Alive', move_count = 0):
      self.color = color
      self.position = position
      self.status = status
      self.name = name
      self.move_count = move_count

  def moveguard(required_positions, the_board):
    occupied_spaces = []
    #for loop over the list of required positions to see if they are present in the occupied positions list
    #if there is a match print 'there seems to be a piece in your way...'
    
  def take_guard(target_position, the_board, valid_take = False):
    #make a list of spaces occupied by white pieces
    #make a separate list of spaces occupied by black pieces
    #check your target position against the list of opposite color piece locations
    #if the target position is not on the list, print 'there is no enemy there'
    pass

class King(ChessPiece):
  def move(self, the_board):
    board_columns = ['A','B','C','D','E','F','G','H']
    direction = input('Which direction? (U,D,L,R,UL,UR,DL,DR)')
    original_position = self.position
    current_column = board_columns.index(self.position[0])
    #try except block
    if direction == 'U':
      target_position = [self.position[0] , self.position[1] - 1]
    elif direction == 'D':
      target_position = [self.position[0] , self.position[1] + 1]
    elif direction == 'L':
      target_position = [board_columns[current_column -1] , self.position[1]]
    elif direction == 'R':
      target_position = [board_columns[current_column +1] , self.position[1]]
    elif direction == 'UL':
      target_position = [board_columns[current_column -1] , self.position[1]-1]
    elif direction == 'UR':
      target_position = [board_columns[current_column +1] , self.position[1]-1]
    elif direction == 'DR':
      target_position = [board_columns[current_column +1] , self.position[1]+1]
    elif direction == 'DL':
      target_position = [board_columns[current_column -1] , self.position[1]+1]
    all_pieces = {**the_board.pieces['white_pieces'],**the_board.pieces['black_pieces']}
    keys, values = zip(*all_pieces.items())
    occupied = False
    for piececheck in values:
      if piececheck.position == target_position:
        occupied = True
    if occupied == True:
      print("Sorry, already a piece there")
    else:
      self.position = target_position
    if original_position != self.position:
      self.move_count += 1
WK = King('White',['E',8], 'WK')
BK = King('White',['E',1], 'BK')

class Queen(ChessPiece):
  def move(self, the_board):
    board_columns = ['A','B','C','D','E','F','G','H']
    direction = input('Which direction? (U,D,L,R,UL,UR,DL,DR)')
    distance = input('how many squares?')
    distance = int(distance)
    original_position = self.position
    current_column = board_columns.index(self.position[0])
    #try except block
    if direction == 'U':
      target_position = [self.position[0] , self.position[1] - distance]
    elif direction == 'D':
      target_position = [self.position[0] , self.position[1] + distance]
    elif direction == 'L':
      target_position = [board_columns[current_column -distance] , self.position[1]]
    elif direction == 'R':
      target_position = [board_columns[current_column +distance] , self.position[1]]
    elif direction == 'UL':
      target_position = [board_columns[current_column -distance] , self.position[1]-distance]
    elif direction == 'UR':
      target_position = [board_columns[current_column +distance] , self.position[1]-distance]
    elif direction == 'DR':
      target_position = [board_columns[current_column +distance] , self.position[1]+distance]
    elif direction == 'DL':
      target_position = [board_columns[current_column -distance] , self.position[1]+distance]
    all_pieces = {**the_board.pieces['white_pieces'],**the_board.pieces['black_pieces']}
    keys, values = zip(*all_pieces.items())
    #else: print 'not a valid entry... try again!'
    occupied = False
    for piececheck in values:
      if piececheck.position == target_position:
        occupied = True
    if occupied == True:
      print("Sorry, already a piece there")
    else:
      self.position = target_position
    if original_position != self.position:
      self.move_count += 1

WQ = Queen('White',['D',8], 'WQ')
BQ = Queen('Black',['D',1], 'BQ')

class Bishop(ChessPiece):
  def move(self, the_board):
    board_columns = ['A','B','C','D','E','F','G','H']
    direction = input('Which direction? (UL,UR,DL,DR)')
    distance = input('how many squares?')
    distance = int(distance)
    original_position = self.position
    current_column = board_columns.index(self.position[0])
    #try except block
    if direction == 'U':

WB1 = Bishop('White',['C',8], 'WB1')
WB2 = Bishop('White',['F',8], 'WB2')
BB1 = Bishop('Black',['C',1], 'BB1')
BB2 = Bishop('Black',['F',1], 'BB2')

class Knight(ChessPiece):
  def move(self, the_board):
    board_columns = ['A','B','C','D','E','F','G','H']
    direction = input('Which direction? (UUL,UUR,ULL,URR,DDL,DDR,DLL,DRR')
    original_position = self.position
    current_column = board_columns.index(self.position[0])
    if direction == 'UUL':
      target_position = [board_columns[current_column -1] , self.position[1] - 2]    
    elif direction == 'UUR':
      target_position = [board_columns[current_column +1] , self.position[1] - 2] 
    elif direction == 'ULL':
      target_position = [board_columns[current_column -2] , self.position[1] - 1]
    elif direction == 'URR':
      target_position = [board_columns[current_column +2] , self.position[1] - 1]  
    elif direction == 'DLL':
      target_position = [board_columns[current_column -2] , self.position[1] + 1]
    elif direction == 'DRR':
      target_position = [board_columns[current_column +2] , self.position[1] + 1]   
    elif direction == 'DDL':
      target_position = [board_columns[current_column -1] , self.position[1] + 2]
    elif direction == 'DDR':
      target_position = [board_columns[current_column +1] , self.position[1] + 2]   
    all_pieces = {**the_board.pieces['white_pieces'],**the_board.pieces['black_pieces']}
    keys, values = zip(*all_pieces.items())
    occupied = False
    for piececheck in values:
      if piececheck.position == target_position:
        occupied = True
    if occupied == True:
      print("Sorry, already a piece there")
    else:
      self.position = target_position
    if original_position != self.position:
      self.move_count += 1
WKn1 = Knight('White',['B',8], 'WKn1')
WKn2 = Knight('White',['G',8], 'WKn2')
BKn1 = Knight('Black',['B',1], 'BKn1')
BKn2 = Knight('Black',['G',1], 'BKn2')

class Rook(ChessPiece):
  def move(direction, length):
    pass

WR1 = Rook('White',['A',8], 'WR1')
WR2 = Rook('White',['H',8], 'WR2')
BR1 = Rook('Black',['A',1], 'BR1')
BR2 = Rook('Black',['H',1], 'BR2')

class Pawn(ChessPiece):
  def __init__(self, color, position, name, status = 'Alive', move_count = 0):
      self.color = color
      self.position = position
      self.status = status
      self.name = name
      self.move_count = move_count
  def move(self, the_board):  
    if self.color == 'White':
      original_position = self.position
      target_position = [self.position[0] , self.position[1] - 1]
    else:
      original_position = self.position
      target_position = [self.position[0] , self.position[1] + 1]
      ### if there is no piece at the target destination
    all_pieces = {**board.pieces['black_pieces'],**board.pieces['white_pieces']}
    occupied = False
    for piececheck in all_pieces.values():
      if piececheck.position == target_position:
        occupied = True
    if occupied == True:
      print("Sorry, already a piece there")
    else:
      self.position = target_position
    if original_position != self.position:
      self.move_count += 1

  def take(self, the_board):
    pass

"""
      move_count += 1
      if move count !=
   # self.previous_move = 'True'

"""
WP1 = Pawn('White',['A',7], 'WP1') ; WP2 = Pawn('White',['B',7], 'WP2') ; WP3 = Pawn('White',['C',7], 'WP3') ; WP4 = Pawn('White',['D',7], 'WP4')
WP5 = Pawn('White',['E',7], 'WP5') ; WP6 = Pawn('White',['F',7], 'WP6') ; WP7 = Pawn('White',['G',7], 'WP7') ; WP8 = Pawn('White',['H',7], 'WP8')
BP1 = Pawn('Black',['A',2], 'BP1') ; BP2 = Pawn('Black',['B',2], 'BP2') ; BP3 = Pawn('Black',['C',2], 'BP3') ; BP4 = Pawn('Black',['D',2], 'BP4')
BP5 = Pawn('Black',['E',2], 'BP5') ; BP6 = Pawn('Black',['F',2], 'BP6') ; BP7 = Pawn('Black',['G',2], 'BP7') ; BP8 = Pawn('Black',['H',2], 'BP8')

class Chessboard:
    def __init__(self):
        self.pieces = {
            'black_pieces' : { 'BK' : BK,'BQ' : BQ,'BB1' : BB1,'BB2' : BB2,'BKn1':BKn1,'BKn2':BKn2,'BR1':BR1,
                              'BR2':BR2,'BP1':BP1,'BP2':BP2,'BP3':BP3,'BP4':BP4,'BP5':BP5,'BP6':BP6,'BP7':BP7,'BP8':BP8},
            'white_pieces' : {'WK':WK,'WQ':WQ,'WB1':WB1,'WB2':WB2,'WKn1':WKn1,'WKn2':WKn2,'WR1':WR1, 'WR2':WR2,
                              'WP1':WP1,'WP2':WP2,'WP3':WP3,'WP4':WP4,'WP5':WP5,'WP6':WP6,'WP7':WP7,'WP8':WP8}
}

    def render(self):   ### put in the argument of the piece dictionary to populate the board
            board = np.full([8,8], ['B'])
            l = np.tile((np.linspace(1,8,8)),(8,1))  ;   m = l.T
            synthetic_array = l+m
            synthetic_boolean = synthetic_array%2 == 1
            board[synthetic_boolean] = 'W'
            pdboard = pd.DataFrame(board, columns = ['A','B','C','D','E','F','G','H'])
            pdboard2 = pdboard.sort_index(axis = 0, ascending = False)  ; pdboard2.index += 1
            placement_array = ['A','B','C','D','E','F','G','H']
            for name, piece in self.pieces['black_pieces'].items():
              if piece.status == 'Alive':
                for itr in range(len(placement_array)):
                  if placement_array[itr] == piece.position[0]:
                    pdboard2.iloc[(piece.position[1]-1,itr)] = piece.name     
            for name, piece in self.pieces['white_pieces'].items():
              if piece.status == 'Alive':
                for itr in range(len(placement_array)):
                  if placement_array[itr] == piece.position[0]:
                    pdboard2.iloc[(piece.position[1]-1,itr)] = piece.name           
      ###  for piece in self.pieces.item:
          

            return pdboard2

board = Chessboard()

def PlayChess(gameboard):
  game_over = False
  total_moves = 0
  while game_over == False:
    if total_moves%2 == 0:
      selection = input('Choose White Piece: ')
      selection_ = gameboard.pieces['white_pieces'][selection]
    else:
      selection = input('Choose Black Piece: ')
      selection_ = gameboard.pieces['black_pieces'][selection]
    Action = input('Move (m), Take(t), or Castle(c)')
    
    if Action == 'm':
      selection_.move(gameboard)
      print(gameboard.render())
      #move_on = input('Move on?')
    elif Action == 't':
      pass
    elif Action == 'c':
      pass
    total_moves +=1
    gameboard.render()

PlayChess(board)